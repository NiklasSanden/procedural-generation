this->sourceCode = {"#version 450 core\nout vec4 FragColour;\n\nin vec3 FragPosView;\nin vec3 Normal;\n\nstruct Material {\n	vec3 diffuse;   // diffuse and ambient is the same on the material\n	vec3 specular;  \n	vec3 emission;  // the diffuse, specular, and emission can be turned into textures for more detail\n	float shininess;\n};\nuniform Material material;\n\nstruct DirectionalLight {\n	bool exists;\n    vec3 direction; // this is in viewcoordinates\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};  \nuniform DirectionalLight directionalLight;\n\nvec3 CalculateDirectionalLight(DirectionalLight light, vec3 normal, vec3 viewDirection);\n\nvoid main()\n{\n    vec3 normal = normalize(Normal);\n    vec3 viewDirection = normalize(-FragPosView);\n\n    // phase 1: Directional lighting\n    vec3 result = vec3(0.0, 0.0, 0.0);\n	if (directionalLight.exists) {\n		result += CalculateDirectionalLight(directionalLight, normal, viewDirection);\n	}\n    \n	// emission\n	result += material.emission;\n\n    FragColour = vec4(result, 1.0);\n}\n\nvec3 CalculateDirectionalLight(DirectionalLight light, vec3 normal, vec3 viewDirection) {\n	vec3 lightDirection = normalize(-light.direction);\n	// diffuse\n	float difference = max(dot(normal, lightDirection), 0.0);\n	// specular\n	vec3 reflectDirection = reflect(-lightDirection, normal);\n	float spec = pow(max(dot(viewDirection, reflectDirection), 0.0), material.shininess);\n	// combine\n	vec3 ambient  = light.ambient * material.diffuse; \n	vec3 diffuse  = light.diffuse * difference * material.diffuse;\n	vec3 specular = light.specular * spec * material.specular;\n\n	return (ambient + diffuse + specular);\n}\n", "#version 450 core\nlayout (location = 0) in vec3 aPos;\nlayout (location = 1) in vec3 aNormal;\n\nout vec3 FragPosView;\nout vec3 Normal;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\nuniform mat3 normal;\n\nvoid main()\n{\n    gl_Position = projection * view * model * vec4(aPos, 1.0);\n\n	FragPosView = vec3(view * model * vec4(aPos, 1.0));\n	Normal = normal * aNormal;\n}\n", "#version 450 core\nout vec4 FragColour;\n\nin vec3 FragPosView;\nin vec3 Normal;\n\nstruct Material {\n	vec3 diffuse;   // diffuse and ambient is the same on the material\n	vec3 specular;  \n	vec3 emission; // the diffuse, specular, and emission can be turned into textures for more detail\n	float shininess;\n};\nuniform Material material;\n\nstruct DirectionalLight {\n	bool exists;\n    vec3 direction; // this is in viewcoordinates\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};  \nuniform DirectionalLight directionalLight;\n\nstruct PointLight {    \n	bool exists;\n    vec3 position; // this is in viewcoordinates\n    \n    float constant;\n    float linear;\n    float quadratic;  \n\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};  \n// Calculate the four closest point lights\n#define NR_POINT_LIGHTS 4\nuniform PointLight pointLights[NR_POINT_LIGHTS];\n\nvec3 CalculateDirectionalLight(DirectionalLight light, vec3 normal, vec3 viewDirection);\nvec3 CalculatePointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDirection);  \n\nvoid main()\n{\n    vec3 normal = normalize(Normal);\n    vec3 viewDirection = normalize(-FragPosView);\n\n    // phase 1: Directional lighting\n    vec3 result = vec3(0.0, 0.0, 0.0);\n	if (directionalLight.exists) {\n		result += CalculateDirectionalLight(directionalLight, normal, viewDirection);\n	}\n    // phase 2: Point lights\n	for (int i = 0; i < NR_POINT_LIGHTS; i++) {\n		if (pointLights[i].exists) {\n			result += CalculatePointLight(pointLights[i], normal, FragPosView, viewDirection);    \n		}\n	}\n    // phase 3: Spot light\n    // TODO: result += CalcSpotLight(spotLight, norm, FragPos, viewDir);    \n    \n	// emission\n	result += material.emission;\n\n    FragColour = vec4(result, 1.0);\n}\n\nvec3 CalculateDirectionalLight(DirectionalLight light, vec3 normal, vec3 viewDirection) {\n	vec3 lightDirection = normalize(-light.direction);\n	// diffuse\n	float difference = max(dot(normal, lightDirection), 0.0);\n	// specular\n	vec3 reflectDirection = reflect(-lightDirection, normal);\n	float spec = pow(max(dot(viewDirection, reflectDirection), 0.0), material.shininess);\n	// combine\n	vec3 ambient  = light.ambient * material.diffuse; \n	vec3 diffuse  = light.diffuse * difference * material.diffuse;\n	vec3 specular = light.specular * spec * material.specular;\n\n	return (ambient + diffuse + specular);\n}\n\nvec3 CalculatePointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDirection)\n{\n    vec3 lightDirection = normalize(light.position - fragPos);\n    // diffuse\n    float difference = max(dot(normal, lightDirection), 0.0);\n    // specular\n    vec3 reflectDirection = reflect(-lightDirection, normal);\n    float spec = pow(max(dot(viewDirection, reflectDirection), 0.0), material.shininess);\n    // attenuation\n    float distance    = length(light.position - fragPos);\n    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));    \n    // combine\n    vec3 ambient  = light.ambient  * material.diffuse;\n    vec3 diffuse  = light.diffuse  * difference * material.diffuse;\n    vec3 specular = light.specular * spec * material.specular;\n    ambient  *= attenuation;\n    diffuse  *= attenuation;\n    specular *= attenuation;\n\n    return (ambient + diffuse + specular);\n} \n", "#version 450 core\nlayout (location = 0) in vec3 aPos;\nlayout (location = 1) in vec3 aNormal;\n\nout vec3 FragPosView;\nout vec3 Normal;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\nuniform mat3 normal;\n\nvoid main()\n{\n    gl_Position = projection * view * model * vec4(aPos, 1.0);\n\n	FragPosView = vec3(view * model * vec4(aPos, 1.0));\n	Normal = normal * aNormal;\n}", "#version 450 core\nlayout(local_size_x = 1, local_size_y = 1) in;\nlayout(rgba32f, binding = 0) uniform image2D img_output;", "#version 450 core\nout vec4 FragColour;\n\nin vec3 FragPosView;\nin vec3 Normal;\n\nstruct Material {\n	vec3 diffuse;   // diffuse and ambient is the same on the material\n	vec3 specular;  \n	vec3 emission; // the diffuse, specular, and emission can be turned into textures for more detail\n	float shininess;\n};\nuniform Material material;\n\nstruct DirectionalLight {\n	bool exists;\n    vec3 direction; // this is in viewcoordinates\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};  \nuniform DirectionalLight directionalLight;\n\nstruct PointLight {    \n	bool exists;\n    vec3 position; // this is in viewcoordinates\n    \n    float constant;\n    float linear;\n    float quadratic;  \n\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};  \n// Calculate the four closest point lights\n#define NR_POINT_LIGHTS 4\nuniform PointLight pointLights[NR_POINT_LIGHTS];\n\nvec3 CalculateDirectionalLight(DirectionalLight light, vec3 normal, vec3 viewDirection);\nvec3 CalculatePointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDirection);  \n\nvoid main()\n{\n	FragColour = vec4(0.5, 0.0, 0.0, 1.0);\n	return;\n\n    vec3 normal = normalize(Normal);\n    vec3 viewDirection = normalize(-FragPosView);\n\n    // phase 1: Directional lighting\n    vec3 result = vec3(0.0, 0.0, 0.0);\n	if (directionalLight.exists) {\n		result += CalculateDirectionalLight(directionalLight, normal, viewDirection);\n	}\n    // phase 2: Point lights\n	for (int i = 0; i < NR_POINT_LIGHTS; i++) {\n		if (pointLights[i].exists) {\n			result += CalculatePointLight(pointLights[i], normal, FragPosView, viewDirection);    \n		}\n	}\n    // phase 3: Spot light\n    // TODO: result += CalcSpotLight(spotLight, norm, FragPos, viewDir);    \n    \n	// emission\n	result += material.emission;\n\n    FragColour = vec4(result, 1.0);\n}\n\nvec3 CalculateDirectionalLight(DirectionalLight light, vec3 normal, vec3 viewDirection) {\n	vec3 lightDirection = normalize(-light.direction);\n	// diffuse\n	float difference = max(dot(normal, lightDirection), 0.0);\n	// specular\n	vec3 reflectDirection = reflect(-lightDirection, normal);\n	float spec = pow(max(dot(viewDirection, reflectDirection), 0.0), material.shininess);\n	// combine\n	vec3 ambient  = light.ambient * material.diffuse; \n	vec3 diffuse  = light.diffuse * difference * material.diffuse;\n	vec3 specular = light.specular * spec * material.specular;\n\n	return (ambient + diffuse + specular);\n}\n\nvec3 CalculatePointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDirection)\n{\n    vec3 lightDirection = normalize(light.position - fragPos);\n    // diffuse\n    float difference = max(dot(normal, lightDirection), 0.0);\n    // specular\n    vec3 reflectDirection = reflect(-lightDirection, normal);\n    float spec = pow(max(dot(viewDirection, reflectDirection), 0.0), material.shininess);\n    // attenuation\n    float distance    = length(light.position - fragPos);\n    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));    \n    // combine\n    vec3 ambient  = light.ambient  * material.diffuse;\n    vec3 diffuse  = light.diffuse  * difference * material.diffuse;\n    vec3 specular = light.specular * spec * material.specular;\n    ambient  *= attenuation;\n    diffuse  *= attenuation;\n    specular *= attenuation;\n\n    return (ambient + diffuse + specular);\n} \n", "#version 450 core\nlayout (points) in;\nlayout (triangle_strip, max_vertices = 100) out;\n\nout vec3 FragPosView;\nout vec3 Normal;\n\nin VS_OUT{\n	vec3 chunkPosition;\n	vec3 vertexPositions[8];\n	float noiseValues[8];\n} gs_in[];\n\nconst int edgeTable[12][2]   = { { 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 0 }, { 4, 5 }, { 5, 6 }, { 6, 7 }, { 7, 4 }, { 0, 4 }, { 1, 5 }, { 2, 6 }, { 3, 7 } };\n\nuniform float cellLength;\n\n// no model matrix necessary\nuniform mat4 view;\nuniform mat4 projection;\nuniform mat3 normal;\n\nvoid main() {\n	const float surfaceLevel = 0.5;\n	const int triTable[256][16] = {{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1},{3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1},{3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1},{3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1},{9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1},{1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1},{9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},{2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1},{8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1},{9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},{4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1},{3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1},{1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1},{4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1},{4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1},{9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1},{1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},{5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1},{2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1},{9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},{0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},{2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1},{10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1},{4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1},{5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1},{5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1},{9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1},{0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1},{1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1},{10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1},{8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1},{2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1},{7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1},{9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1},{2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1},{11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1},{9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1},{5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1},{11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1},{11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},{1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1},{9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1},{5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1},{2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},{0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},{5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1},{6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1},{0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1},{3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1},{6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1},{5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1},{1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},{10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1},{6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1},{1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1},{8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1},{7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1},{3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},{5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1},{0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1},{9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1},{8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1},{5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1},{0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1},{6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1},{10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1},{10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1},{8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1},{1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1},{3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1},{0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1},{10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1},{0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1},{3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1},{6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1},{9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1},{8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1},{3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1},{6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1},{0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1},{10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1},{10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1},{1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1},{2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1},{7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1},{7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1},{2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1},{1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1},{11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1},{8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1},{0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1},{7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},{10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},{2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},{6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1},{7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1},{2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1},{1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1},{10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1},{10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1},{0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1},{7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1},{6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1},{8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1},{9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1},{6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1},{1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1},{4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1},{10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1},{8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1},{0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1},{1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1},{8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1},{10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1},{4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1},{10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},{5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},{11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1},{9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},{6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1},{7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1},{3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1},{7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1},{9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1},{3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1},{6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1},{9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1},{1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1},{4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1},{7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1},{6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1},{3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1},{0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1},{6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1},{1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1},{0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1},{11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1},{6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1},{5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1},{9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1},{1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1},{1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1},{10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1},{0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1},{5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1},{10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1},{11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1},{0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1},{9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1},{7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1},{2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1},{8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1},{9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1},{9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1},{1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1},{9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1},{9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1},{5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1},{0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1},{10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1},{2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1},{0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1},{0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1},{9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1},{5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1},{3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1},{5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1},{8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1},{0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1},{9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1},{0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1},{1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1},{3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1},{4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1},{9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1},{11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1},{11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1},{2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1},{9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1},{3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1},{1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1},{4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1},{4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1},{0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1},{3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1},{3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1},{0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1},{9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1},{1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}};\n\n	vec3 chunkPosition = gs_in[0].chunkPosition;\n	vec3 cellPosition = vec3(gl_in[0].gl_Position);\n\n	int cubeIndex = 0;\n	for (int i = 0; i < 8; i++) {\n		if (gs_in[0].noiseValues[i] < surfaceLevel) {\n			cubeIndex |= 1 << i;\n		}\n	}\n\n\n	for (int i = 0; i < 12; i++) {\n		if (triTable[cubeIndex][i] == -1) break;\n\n		int indexA = edgeTable[triTable[cubeIndex][i]][0];\n		int indexB = edgeTable[triTable[cubeIndex][i]][1];\n\n		vec3 tempVertexPos = (gs_in[0].vertexPositions[indexA] + gs_in[0].vertexPositions[indexB]) / 2.0;\n		gl_Position = projection * view * vec4(chunkPosition + cellPosition + tempVertexPos, 1.0);\n		EmitVertex();\n\n\n		if ((i + 1) % 3 == 0) {\n			EndPrimitive();\n		}\n	}\n\n\n\n	// ---------------------------\n	// OLD\n	// ---------------------------\n\n	// Bottom\n//	Normal = normal * vec3(0.0, 0.0, -1.0);\n//\n//	vertexPosition = vec3(0.0, 0.0, -cellLength * cellLengthFactor);\n//	FragPosView = vec3(view * vec4(chunkPosition + cellPosition + vertexPosition, 1.0));\n//	gl_Position = projection * view * vec4(chunkPosition + cellPosition + vertexPosition, 1.0);\n//	EmitVertex();\n\n//	EndPrimitive();\n\n\n	//FragPosView = vec3(view * model * vec4(aPos, 1.0));\n	//Normal = normal * aNormal;\n}\n\n//	vec3 vertexPositions[] = {\n//		vec3(0.0, 0.0, 0.0),\n//		vec3(cellLength, 0.0, 0.0),\n//		vec3(0.0, cellLength, 0.0),\n//		vec3(cellLength, cellLength, 0.0),\n//		vec3(0.0, 0.0, -cellLength),\n//		vec3(cellLength, 0.0, -cellLength),\n//		vec3(0.0, cellLength, -cellLength),\n//		vec3(cellLength, cellLength, -cellLength)\n//	};\n", "#version 450 core\nlayout (location = 0) in vec3 aCellPos;\nlayout (location = 1) in vec3 aChunkPosition;\n\nout VS_OUT{\n	vec3 chunkPosition;\n	vec3 vertexPositions[8];\n	float noiseValues[8];\n} vs_out;\n\nuniform float cellLength;\n\nconst int permuations[] = { 151,160,137,91,90,15,										131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,		190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,	88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,	77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,	102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,	135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,	5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,	223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,	129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,	251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,	49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,	138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n							151,160,137,91,90,15,										131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,		190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,	88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,	77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,	102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,	135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,	5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,	223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,	129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,	251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,	49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,	138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n};\n\nfloat octavePerlin(float x, float y, float z, int octaves, float persistence);\nfloat perlin(float x, float y, float z);\nfloat grad(int hash, float x, float y, float z);\nfloat fade(float t);\nfloat lerp(float a, float b, float x);\n\nvoid main() {\n    gl_Position = vec4(aCellPos, 1.0);\n	vs_out.chunkPosition = aChunkPosition;\n	\n	vs_out.vertexPositions[0] = vec3(0.0, 0.0, 0.0);\n	vs_out.vertexPositions[1] = vec3(0.0, 0.0, -cellLength);\n	vs_out.vertexPositions[2] = vec3(cellLength, 0.0, -cellLength);\n	vs_out.vertexPositions[3] = vec3(cellLength, 0.0, 0.0);\n	vs_out.vertexPositions[4] = vec3(0.0, cellLength, 0.0);\n	vs_out.vertexPositions[5] = vec3(0.0, cellLength, -cellLength);\n	vs_out.vertexPositions[6] = vec3(cellLength, cellLength, -cellLength);\n	vs_out.vertexPositions[7] = vec3(cellLength, cellLength, 0.0);\n\n	for (int i = 0; i < 8; i++) {\n		vs_out.noiseValues[i] = octavePerlin(vs_out.vertexPositions[i].x + aChunkPosition.x + aCellPos.x, \n											 vs_out.vertexPositions[i].y + aChunkPosition.y + aCellPos.y, \n											 vs_out.vertexPositions[i].z + aChunkPosition.z + aCellPos.z, \n											 1,\n											 1.0);\n	}\n}\n\nfloat octavePerlin(float x, float y, float z, int octaves, float persistence) {\n	x = abs(x + 100000.0);\n	y = abs(y + 100000.0);\n	z = abs(z + 100000.0);\n\n	float total = 0.0;\n	float frequency = 1.0;\n	float amplitude = 1.0;\n	float maxValue = 0.0;			// Used for normalizing result to 0.0 - 1.0\n	for (int i = 0; i < octaves; i++) {\n		total += perlin(x * frequency, y * frequency, z * frequency) * amplitude;\n			\n		maxValue += amplitude;\n			\n		amplitude *= persistence;\n		frequency *= 2.0;\n	}\n		\n	return total / maxValue;\n}\n\nfloat perlin(float x, float y, float z) {\n	int xi = int(x) & 255;								// Calculate the unit cube that the point asked will be located in\n	int yi = int(y) & 255;								// The left bound is ( |_x_|,|_y_|,|_z_| ) and the right bound is that\n	int zi = int(z) & 255;								// plus 1.  Next we calculate the location (from 0.0 to 1.0) in that cube.\n	float xf = x - int(x);								// We also fade the location to smooth the result.\n	float yf = y - int(y);\n	float zf = z - int(z);\n	float u = fade(xf);\n	float v = fade(yf);\n	float w = fade(zf);\n															\n	int aaa, aba, aab, abb, baa, bba, bab, bbb;\n	aaa = permuations[permuations[permuations[xi    ] + yi    ] + zi    ];\n	aba = permuations[permuations[permuations[xi    ] + yi + 1] + zi    ];\n	aab = permuations[permuations[permuations[xi    ] + yi    ] + zi + 1];\n	abb = permuations[permuations[permuations[xi    ] + yi + 1] + zi + 1];\n	baa = permuations[permuations[permuations[xi + 1] + yi    ] + zi    ];\n	bba = permuations[permuations[permuations[xi + 1] + yi + 1] + zi    ];\n	bab = permuations[permuations[permuations[xi + 1] + yi    ] + zi + 1];\n	bbb = permuations[permuations[permuations[xi + 1] + yi + 1] + zi + 1];\n	\n	float x1, x2, y1, y2;\n	x1 = lerp(	grad (aaa, xf      , yf  , zf),				// The gradient function calculates the dot product between a pseudorandom\n				grad (baa, xf - 1.0, yf  , zf),				// gradient vector and the vector from the input coordinate to the 8\n				u);										// surrounding points in its unit cube.\n	x2 = lerp(	grad (aba, xf      , yf - 1.0, zf),				// This is all then lerped together as a sort of weighted average based on the faded (u,v,w)\n				grad (bba, xf - 1.0, yf - 1.0, zf),				// values we made earlier.\n			        u);\n	y1 = lerp(x1, x2, v);\n\n	x1 = lerp(	grad (aab, xf      , yf  , zf - 1.0),\n				grad (bab, xf - 1.0, yf  , zf - 1.0),\n				u);\n	x2 = lerp(	grad (abb, xf      , yf - 1.0, zf - 1.0),\n		        grad (bbb, xf - 1.0, yf - 1.0, zf - 1.0),\n		        u);\n	y2 = lerp (x1, x2, v);\n		\n	return (lerp (y1, y2, w) + 1.0) / 2.0;						// For convenience we bound it to 0 - 1 (theoretical min/max before is -1 - 1)\n}\n\nfloat grad(int hash, float x, float y, float z) {\n	int h = hash & 15;									// Take the hashed value and take the first 4 bits of it (15 == 0b1111)\n	float u = h < 8 /* 0b1000 */ ? x : y;				// If the most significant bit (MSB) of the hash is 0 then set u = x.  Otherwise y.\n		\n	float v;											// In Ken Perlin's original implementation this was another conditional operator (?:).  I\n														// expanded it for readability.\n		\n	if(h < 4 /* 0b0100 */)								// If the first and second significant bits are 0 set v = y\n		v = y;\n	else if(h == 12 /* 0b1100 */ || h == 14 /* 0b1110*/)// If the first and second significant bits are 1 set v = x\n		v = x;\n	else 												// If the first and second significant bits are not equal (0/1, 1/0) set v = z\n		v = z;\n		\n	return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v); // Use the last 2 bits to decide if u and v are positive or negative.  Then return their addition.\n}\n	\nfloat fade(float t) {\n														// Fade function as defined by Ken Perlin.  This eases coordinate values\n														// so that they will ease towards integral values.  This ends up smoothing\n														// the final output.\n	return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);			// 6t^5 - 15t^4 + 10t^3\n}\n	\nfloat lerp(float a, float b, float x) {\n	return a + x * (b - a);\n}\n", "#version 450 core\nout vec4 FragColour;\n\nin vec2 texCoord;\n\n// textures\nuniform sampler2D texture0;\n\nvoid main()\n{\n	FragColour = texture(texture0, texCoord);\n}", "#version 450 core\nlayout (location = 0) in vec3 aPos;\nlayout (location = 1) in vec2 aTexCoord;\n\nout vec2 texCoord;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\nuniform mat4 normal;\n\nvoid main()\n{\n    gl_Position = projection * view * model * vec4(aPos, 1.0);\n	texCoord = aTexCoord;\n}" };
this->fileNames = { "chunk.frag", "chunk.vert", "default.frag", "default.vert", "marchingCubes.comp", "marchingCubes.frag", "marchingCubes.geom", "marchingCubes.vert", "textureDefault.frag", "textureDefault.vert" };